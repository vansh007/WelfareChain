/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface SchemeRegistryInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "applyForScheme"
      | "approveApplication"
      | "createScheme"
      | "getSchemeDetails"
      | "getUserApplications"
      | "isBeneficiary"
      | "ministries"
      | "registerMinistry"
      | "rejectApplication"
      | "schemes"
      | "userApplications"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ApplicationApproved"
      | "ApplicationRejected"
      | "ApplicationSubmitted"
      | "MinistryRegistered"
      | "SchemeCreated"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "applyForScheme",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approveApplication",
    values: [BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "createScheme",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getSchemeDetails",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserApplications",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isBeneficiary",
    values: [BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "ministries",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerMinistry",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "rejectApplication",
    values: [BytesLike, AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "schemes", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "userApplications",
    values: [AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "applyForScheme",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveApplication",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createScheme",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSchemeDetails",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserApplications",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBeneficiary",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ministries", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "registerMinistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rejectApplication",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "schemes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "userApplications",
    data: BytesLike
  ): Result;
}

export namespace ApplicationApprovedEvent {
  export type InputTuple = [schemeId: BytesLike, applicant: AddressLike];
  export type OutputTuple = [schemeId: string, applicant: string];
  export interface OutputObject {
    schemeId: string;
    applicant: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ApplicationRejectedEvent {
  export type InputTuple = [schemeId: BytesLike, applicant: AddressLike];
  export type OutputTuple = [schemeId: string, applicant: string];
  export interface OutputObject {
    schemeId: string;
    applicant: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ApplicationSubmittedEvent {
  export type InputTuple = [schemeId: BytesLike, applicant: AddressLike];
  export type OutputTuple = [schemeId: string, applicant: string];
  export interface OutputObject {
    schemeId: string;
    applicant: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MinistryRegisteredEvent {
  export type InputTuple = [ministryAddress: AddressLike, name: string];
  export type OutputTuple = [ministryAddress: string, name: string];
  export interface OutputObject {
    ministryAddress: string;
    name: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SchemeCreatedEvent {
  export type InputTuple = [
    schemeId: BytesLike,
    name: string,
    ministry: AddressLike
  ];
  export type OutputTuple = [schemeId: string, name: string, ministry: string];
  export interface OutputObject {
    schemeId: string;
    name: string;
    ministry: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface SchemeRegistry extends BaseContract {
  connect(runner?: ContractRunner | null): SchemeRegistry;
  waitForDeployment(): Promise<this>;

  interface: SchemeRegistryInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  applyForScheme: TypedContractMethod<
    [_schemeId: BytesLike],
    [void],
    "nonpayable"
  >;

  approveApplication: TypedContractMethod<
    [_schemeId: BytesLike, _applicant: AddressLike],
    [void],
    "nonpayable"
  >;

  createScheme: TypedContractMethod<
    [_name: string, _description: string, _maxBeneficiaries: BigNumberish],
    [void],
    "nonpayable"
  >;

  getSchemeDetails: TypedContractMethod<
    [_schemeId: BytesLike],
    [
      [string, string, string, boolean, bigint, bigint] & {
        name: string;
        description: string;
        ministry: string;
        isActive: boolean;
        maxBeneficiaries: bigint;
        currentBeneficiaries: bigint;
      }
    ],
    "view"
  >;

  getUserApplications: TypedContractMethod<
    [_user: AddressLike],
    [string[]],
    "view"
  >;

  isBeneficiary: TypedContractMethod<
    [_schemeId: BytesLike, _user: AddressLike],
    [boolean],
    "view"
  >;

  ministries: TypedContractMethod<
    [arg0: AddressLike],
    [
      [string, string, boolean] & {
        name: string;
        ministryAddress: string;
        isActive: boolean;
      }
    ],
    "view"
  >;

  registerMinistry: TypedContractMethod<[_name: string], [void], "nonpayable">;

  rejectApplication: TypedContractMethod<
    [_schemeId: BytesLike, _applicant: AddressLike],
    [void],
    "nonpayable"
  >;

  schemes: TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, string, string, boolean, bigint, bigint] & {
        name: string;
        description: string;
        ministry: string;
        isActive: boolean;
        maxBeneficiaries: bigint;
        currentBeneficiaries: bigint;
      }
    ],
    "view"
  >;

  userApplications: TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [string],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "applyForScheme"
  ): TypedContractMethod<[_schemeId: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "approveApplication"
  ): TypedContractMethod<
    [_schemeId: BytesLike, _applicant: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createScheme"
  ): TypedContractMethod<
    [_name: string, _description: string, _maxBeneficiaries: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getSchemeDetails"
  ): TypedContractMethod<
    [_schemeId: BytesLike],
    [
      [string, string, string, boolean, bigint, bigint] & {
        name: string;
        description: string;
        ministry: string;
        isActive: boolean;
        maxBeneficiaries: bigint;
        currentBeneficiaries: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getUserApplications"
  ): TypedContractMethod<[_user: AddressLike], [string[]], "view">;
  getFunction(
    nameOrSignature: "isBeneficiary"
  ): TypedContractMethod<
    [_schemeId: BytesLike, _user: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "ministries"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [
      [string, string, boolean] & {
        name: string;
        ministryAddress: string;
        isActive: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "registerMinistry"
  ): TypedContractMethod<[_name: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "rejectApplication"
  ): TypedContractMethod<
    [_schemeId: BytesLike, _applicant: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "schemes"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, string, string, boolean, bigint, bigint] & {
        name: string;
        description: string;
        ministry: string;
        isActive: boolean;
        maxBeneficiaries: bigint;
        currentBeneficiaries: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "userApplications"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [string],
    "view"
  >;

  getEvent(
    key: "ApplicationApproved"
  ): TypedContractEvent<
    ApplicationApprovedEvent.InputTuple,
    ApplicationApprovedEvent.OutputTuple,
    ApplicationApprovedEvent.OutputObject
  >;
  getEvent(
    key: "ApplicationRejected"
  ): TypedContractEvent<
    ApplicationRejectedEvent.InputTuple,
    ApplicationRejectedEvent.OutputTuple,
    ApplicationRejectedEvent.OutputObject
  >;
  getEvent(
    key: "ApplicationSubmitted"
  ): TypedContractEvent<
    ApplicationSubmittedEvent.InputTuple,
    ApplicationSubmittedEvent.OutputTuple,
    ApplicationSubmittedEvent.OutputObject
  >;
  getEvent(
    key: "MinistryRegistered"
  ): TypedContractEvent<
    MinistryRegisteredEvent.InputTuple,
    MinistryRegisteredEvent.OutputTuple,
    MinistryRegisteredEvent.OutputObject
  >;
  getEvent(
    key: "SchemeCreated"
  ): TypedContractEvent<
    SchemeCreatedEvent.InputTuple,
    SchemeCreatedEvent.OutputTuple,
    SchemeCreatedEvent.OutputObject
  >;

  filters: {
    "ApplicationApproved(bytes32,address)": TypedContractEvent<
      ApplicationApprovedEvent.InputTuple,
      ApplicationApprovedEvent.OutputTuple,
      ApplicationApprovedEvent.OutputObject
    >;
    ApplicationApproved: TypedContractEvent<
      ApplicationApprovedEvent.InputTuple,
      ApplicationApprovedEvent.OutputTuple,
      ApplicationApprovedEvent.OutputObject
    >;

    "ApplicationRejected(bytes32,address)": TypedContractEvent<
      ApplicationRejectedEvent.InputTuple,
      ApplicationRejectedEvent.OutputTuple,
      ApplicationRejectedEvent.OutputObject
    >;
    ApplicationRejected: TypedContractEvent<
      ApplicationRejectedEvent.InputTuple,
      ApplicationRejectedEvent.OutputTuple,
      ApplicationRejectedEvent.OutputObject
    >;

    "ApplicationSubmitted(bytes32,address)": TypedContractEvent<
      ApplicationSubmittedEvent.InputTuple,
      ApplicationSubmittedEvent.OutputTuple,
      ApplicationSubmittedEvent.OutputObject
    >;
    ApplicationSubmitted: TypedContractEvent<
      ApplicationSubmittedEvent.InputTuple,
      ApplicationSubmittedEvent.OutputTuple,
      ApplicationSubmittedEvent.OutputObject
    >;

    "MinistryRegistered(address,string)": TypedContractEvent<
      MinistryRegisteredEvent.InputTuple,
      MinistryRegisteredEvent.OutputTuple,
      MinistryRegisteredEvent.OutputObject
    >;
    MinistryRegistered: TypedContractEvent<
      MinistryRegisteredEvent.InputTuple,
      MinistryRegisteredEvent.OutputTuple,
      MinistryRegisteredEvent.OutputObject
    >;

    "SchemeCreated(bytes32,string,address)": TypedContractEvent<
      SchemeCreatedEvent.InputTuple,
      SchemeCreatedEvent.OutputTuple,
      SchemeCreatedEvent.OutputObject
    >;
    SchemeCreated: TypedContractEvent<
      SchemeCreatedEvent.InputTuple,
      SchemeCreatedEvent.OutputTuple,
      SchemeCreatedEvent.OutputObject
    >;
  };
}
